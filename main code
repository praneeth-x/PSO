import numpy as np
import pandas as pd
import random
import math as m
size=int(input("enter the swarm size\n")) #declares the size
iterations=int(input("enter the number of iterations\n")) #declares no of iterations
c=[0,0]
r=[0,0]
c[0]=int(input("enter the value of c1\n"))
c[1]=int(input("enter the value of c2\n"))
r[0]=float(input("enter the value of r1\n"))
r[1]=float(input("enter the value of r2\n"))
particles=np.random.rand(size,10) #declaring a particle swarm in each row will represent each particle and each column represent respective weights
particles=2*particles-1 #making this operation so the weights are bw -1 to 1
v=np.zeros((size,10)) #initalising the velocities to zero


f=open("DS1_input.txt","r")
time=f.readlines()  #reading time from the file
for i in range(len(time)): #converting the time values from strings to float
    time[i]=float(time[i])
g=open("DS1_output.txt","r") #reading actual output from the file
ce=g.readlines()  #ce stands for cummulative error
for j in range(len(ce)):    #converting the string of data into integers
    ce[j]=float(ce[j])


def cost(t,ce,w):   #defination of cost function
    '''takes time list actual error list and expected weights as input in the given order and returns error as output'''
    cost=0
    for j in range(len(time)):
        out=w[4]*(1-m.exp(-w[0]*t[i]))+w[5]*(1-(1+w[1]*t[i])*(m.exp(-w[1]*t[i])))+(w[6]*(1-(m.exp(-w[2]*t[i]))))/(1+(w[8]*(m.exp(w[2]*t[i]))))+w[7]/(1+w[9]*(m.exp(-w[3]*t[i])))
        cost=cost+((out-ce[j])**2)/2
    return cost

p_best=particles.copy() #creating pbest array each row defining personal best of each particle since initial position is initial personal best position

g_best=particles[0].copy()  #out of randomly genreated weights looking for global best
for j in range(size):
    if(cost(time,ce,g_best)>cost(time,ce,p_best[j])):
        g_best=p_best[j].copy()

w=0.9 #initalising the inertia factor value

for iter in range(iterations):
    for j in range(size):
        v[j]=w*v[j]-c[0]*r[0]*(particles[j]-p_best[j])-c[1]*r[1]*(particles[j]-g_best) #updating velocity first
        particles[j]=particles[j]+v[j] #updating position of particles
        if(particles[j,8]>1):
            particles[j,8]=1
            v[j,8]=0
        if(particles[j,9]>1):
            particles[j,9]=1
            v[j,9]=0
        if(particles[j,9]<0):
            particles[j,9]=0
            v[j,9]=0
        if(particles[j,8]<0):
            particles[j,8]=0
            v[j,8]=0
        if(cost(time,ce,particles[j])<cost(time,ce,p_best[j])): #updating their personal bests
            p_best[j]=particles[j].copy()
        if(cost(time,ce,p_best[j])<cost(time,ce,g_best)): #updating the global bests
            g_best=p_best[j].copy()

    w=w-((0.5)/(size-1))*iter #updation of inertia factor after each and every itertation
G_best = tuple((g_best))
print(g_best)
